% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rap.R
\name{wap}
\alias{wap}
\alias{nap}
\alias{lap}
\alias{wap_dbl}
\alias{wap_lgl}
\alias{wap_int}
\alias{wap_chr}
\alias{wap_raw}
\alias{wap_dfr}
\alias{rap}
\alias{rap_dbl}
\alias{rap_lgl}
\alias{rap_int}
\alias{rap_chr}
\alias{rap_raw}
\alias{rap_dfr}
\title{Map over columns of a data frame simultaneously}
\usage{
wap(.tbl, ..., .ptype = list())

nap(.tbl, ...)

lap(.tbl, ..., .ptype = list())

wap_dbl(.tbl, ...)

wap_lgl(.tbl, ...)

wap_int(.tbl, ...)

wap_chr(.tbl, ...)

wap_raw(.tbl, ...)

wap_dfr(.tbl, ...)

rap(.tbl, ..., .ptype = list())

rap_dbl(.tbl, ...)

rap_lgl(.tbl, ...)

rap_int(.tbl, ...)

rap_chr(.tbl, ...)

rap_raw(.tbl, ...)

rap_dfr(.tbl, ...)
}
\arguments{
\item{.tbl}{A data frame}

\item{...}{A single named formula.

 The rhs of the formula uses columns of `.tbl`, and each stands for a single
 observation.

 Evaluating the rhs of the formula should return a single observation of
 a type identified by `.ptype`. For example if `.ptype` is `integer()` the
 expression should evaluate to a single integer ...}

\item{.ptype}{output type. The default `list()` uses [purrr::map()] to
iterate. No checks are performed on the results.

Can be one of these special cases that take advantage of functions from `purrr`:

- `integer()` : the iteration is performed by [purrr::map_int()]
- `double()` : the iteration is performed by [purrr::map_dbl()]
- `raw()` : the iteration is performed by [purrr::map_raw()]
- `logical()` : the iteration is performed by [purrr::map_lgl()]
- `character()` : the iteration is performed by [purrr::map_chr()]

Can be `data.frame()`. Each result of the formula must be a data frame of
one observation. The data frames are combined with [vctrs::vec_rbind()].

Can be a data frame of a specific type, e.g. `data.frame(x = integer(), y = double())`.
In that case the data frames must also be of one observation, but also must
be of the specified type. They are aggregated with [vctrs::vec_rbind()], passing along
the `.ptype`.

Finally, for any other value of `.ptype`, the expression should give one
observation of that type, and they are combined eventually with [vctrs::vec_c()].}
}
\value{
- `wap()` and its variants return a vector of the appropriate type, e.g. `wap_dbl()` returns
            a numeric vector, `wap_int()` returns an integer vector, ...

  - `rap()` and its variants return a data frame with the additional column

  - `nap()` returns *n*othing, and can be used for side effects, similar to [purrr:::pwalk()]
}
\description{
Map over columns of a data frame simultaneously
}
\details{
Suffixed versions of `wap()` and `rap()` are conveniences set the `.ptype`, e.g.
`wap_int(...)` is `wap(..., .ptype = integer())`, `rap_lgl(...)` is `rap(..., .ptype = logical())`
}
\examples{

library(purrr)
library(dplyr)
library(tibble)

tbl <- tibble(cyl = c(4, 6, 8), mpg = c(30, 25, 20))

# inspired from https://github.com/tidyverse/purrr/issues/280#issuecomment-270844528
# wap returns a list
tbl \%>\%
  wap(~ filter(mtcars, cyl == !!cyl, mpg < !!mpg))

# can use the .ptype to indicate the type of result
# in the vctrs sense:
tbl \%>\%
  wap(~ nrow(filter(mtcars, cyl == !!cyl, mpg < !!mpg)), .ptype = integer())

# or alternatively use the suffixed versions, Ã  la purrr:
tbl \%>\%
  wap_int(~ nrow(filter(mtcars, cyl == !!cyl, mpg < !!mpg)))

# wap(.ptype = data.frame()) or wap_dfr row binds data frames
tbl \%>\%
  wap_dfr(~ data.frame(a = cyl * 2, b = mpg + 1))

# rap adds a column to a data frame
tbl \%>\%
  rap(x = ~filter(mtcars, cyl == !!cyl, mpg < !!mpg)) \%>\%
  rap(n = ~nrow(x), .ptype = integer())

}
